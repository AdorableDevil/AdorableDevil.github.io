---
title: 背包问题
tags: 算法
layout: post
---

## What is 背包问题

> 背包问题（Knapsack problem）是一种组合优化的 NP 完全问题.问题可以描述为:给定一组物品,每种物品都有自己的重量和价格,在限定的总重量内,我们如何选择,才能使得物品的总价格最高.问题的名称来源于如何选择最合适的物品放置于给定背包中.
>
> 相似问题经常出现在商业、组合数学,计算复杂性理论、密码学和应用数学等领域中.

> 也可以将背包问题描述为决定性问题,即在总重量不超过 W 的前提下,总价值是否能达到 V.

## 背包问题的分类

> 1.01 背包问题
>
> 2.完全背包问题
>
> 3.多重背包问题

> 我们有 n 种物品,物品 j 的重量为 wj,价格为 pj.
>
> 我们假定所有物品的重量和价格都是非负的.背包所能承受的最大重量为 W.
>
> 如果限定每种物品只能选择 0 个或 1 个,则问题称为**0-1 背包问题**.
>
> 可以用公式表示为:
>
> 最大化 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/5afdaef4d007e84cf2371df93cf7bdc891ddc1d4)
>
> 受限于 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/4302b7359d0374df8424621a29a8a4f41f8d017c)
>
> 如果限定物品 j 最多只能选择 bj 个,则问题称为**有界背包问题**.
>
> 可以用公式表示为:
>
> 最大化 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/5afdaef4d007e84cf2371df93cf7bdc891ddc1d4)
>
> 受限于![](https://wikimedia.org/api/rest_v1/media/math/render/svg/dcc77ece1703114b78feaf35faa0e99de9b4b34a)
>
> 如果不限定每种物品的数量,则问题称为**无界背包问题** .
>
> 各类复杂的背包问题总可以变换为简单的 0-1 背包问题进行求解.
>
> **完全背包（unbounded knapsack problem）**与 01 背包不同就是每种物品可以有无限多个:一共有 N 种物品,每种物品有无限多个,第 i（i 从 1 开始）种物品的重量为 w[i],价值为 v[i].在总重量不超过背包承载上限 W 的情况下,能够装入背包的最大价值是多少？
>
> **多重背包（bounded knapsack problem）**与前面不同就是每种物品是有限个:一共有 N 种物品,第 i（i 从 1 开始）种物品的数量为 n[i],重量为 w[i],价值为 v[i].在总重量不超过背包承载上限 W 的情况下,能够装入背包的最大价值是多少？

## **动态规划法**求解**0-1 背包问题**

> 在 0/1 背包问题中,物品 i 或者被装入背包,或者不被装入背包,设 xi 表示物品 i 装入背包的情况,则当 xi=0 时,表示物品 i 没有被装入背包,xi=1 时,表示物品 i 被装入背包.根据问题的要求,有如下约束条件和目标函数:
>
>$$
\begin{cases}
\sum^n_{i=1} w_ix_i≤C \\
x_i\in\{0,1\} \qquad (1≤i≤n)
\end{cases}
$$   (式6.9)
>
>$$
max\sum^n_{i=1} v_ix_i≤C
$$   (式6.10)
>
> 于是,问题归结为寻找一个满足约束条件式 6.9,并使目标函数式 6.10 达到最大的解向量 X=(x1, x2, …, xn).
>
> 0/1 背包问题可以看作是决策一个序列(x1, x2, …, xn),对任一变量 xi 的决策是决定 xi=1 还是 xi=0.在对 xi-1 决策后,已确定了(x1, …, xi-1),在决策 xi 时,问题处于下列两种状态之一:
>
> （1）背包容量不足以装入物品 i,则 xi=0,背包不增加价值;
>
> （2）背包容量可以装入物品 i,则 xi=1,背包的价值增加了 vi.
>
> 这两种情况下背包价值的最大者应该是对 xi 决策后的背包价值.令 V(i, j)表示在前 i(1≤i≤n)个物品中能够装入容量为 j（1≤j≤C）的背包中的物品的最大值,则可以得到如下动态规划函数:
>
> V(i, 0)= V(0, j)=0 （式 6.11）
>
> V(i,j)=$$  \begin{cases}
V(i-1,j)    \qquad j＜w_i      \\      
max \{V(i-1,j),V(i-1,j-w_i)+v_i\} \qquad  j>w_i
\end{cases}$$ （式 6.12）
>
> 式 6.11 表明:把前面 i 个物品装入容量为 0 的背包和把 0 个物品装入容量为 j 的背包,得到的价值均为 0.式 6.12 的第一个式子表明:如果第 i 个物品的重量大于背包的容量,则装入前 i 个物品得到的最大价值和装入前 i-1 个物品得到的最大价值是相同的,即物品 i 不能装入背包;第二个式子表明:如果第 i 个物品的重量小于背包的容量,则会有以下两种情况:（1）如果把第 i 个物品装入背包,则背包中物品的价值等于把前 i-1 个物品装入容量为 j-wi 的背包中的价值加上第 i 个物品的价值 vi;（2）如果第 i 个物品没有装入背包,则背包中物品的价值就等于把前 i-1 个物品装入容量为 j 的背包中所取得的价值.显然,取二者中价值较大者作为把前 i 个物品装入容量为 j 的背包中的最优解.
>
> 按下述方法来划分阶段:第一阶段,只装入前 1 个物品,确定在各种情况下的背包能够得到的最大价值;第二阶段,只装入前 2 个物品,确定在各种情况下的背包能够得到的最大价值;依此类推,直到第 n 个阶段.最后,V(n,C)便是在容量为 C 的背包中装入 n 个物品时取得的最大价值.为了确定装入背包的具体物品,从 V(n,C)的值向前推,如果 V(n,C)>V(n-1,C),表明第 n 个物品被装入背包,前 n-1 个物品被装入容量为 C-wn 的背包中;否则,第 n 个物品没有被装入背包,前 n-1 个物品被装入容量为 C 的背包中.依此类推,直到确定第 1 个物品是否被装入背包中为止.由此,得到如下函数:
>
> $ x_i $=$$  \begin{cases}
0     \qquad  V(i,j)=V(i-1,j)  \\      
1,j=j-w_i \qquad  V(i,j)>V(i-1,j)
\end{cases}$$ （式 6.13）
>
> 例如,有 5 个物品,其重量分别是{2, 2, 6, 5, 4},价值分别为{6, 3, 5, 4, 6},背包的容量为 10.
>
> 根据动态规划函数,用一个(n+1)×(C+1)的二维表 V,V[i][j]表示把前 i 个物品装入容量为 j 的背包中获得的最大价值.
>
> 例如,有 5 个物品,其重量分别是{2, 2, 6, 5, 4},价值分别为{6, 3, 5, 4, 6},背包的容量为 10.
>
> 根据动态规划函数,用一个(n+1)×(C+1)的二维表 V,V[i][j]表示把前 i 个物品装入容量为 j 的背包中获得的最大价值.
>
> ![](https://img2018.cnblogs.com/blog/798398/201909/798398-20190901170651326-2046946349.png)
>
> 设 n 个物品的重量存储在数组 w[n]中,价值存储在数组 v[n]中,背包容量为 C,数组 V[n+1][c+1]存放迭代结果,其中 V[i][j]表示前 i 个物品装入容量为 j 的背包中获得的最大价值,数组 x[n]存储装入背包的物品,动态规划法求解 0/1 背包问题的算法如下:

```cpp
int KnapSack(int n, int w[ ], int v[ ])
   {
     for (i=0; i<=n; i++)   //初始化第0列
       V[i][0]=0;
     for (j=0; j<=C; j++)   //初始化第0行
       V[0][j]=0;
     for (i=1; i<=n; i++)   //计算第i行,进行第i次迭代
       for (j=1; j<=C; j++)
          if (j<w[i])
			V[i][j]=V[i-1][j];
         else
			V[i][j]=max(V[i-1][j], V[i-1][j-w[i]]+v[i]);
     j=C;    //求装入背包的物品
     for (i=n; i>0; i--)
     {
       if (V[i][j]>V[i-1][j]) {
         x[i]=1;
         j=j-w[i];
       }
       else x[i]=0;
     }
  return V[n][C];    //返回背包取得的最大价值


```

> 在算法 6.3 中,第一个 for 循环的时间性能是 O(n),第二个 for 循环的时间性能是 O(C),第三个循环是两层嵌套的 for 循环,其时间性能是 O(n×C),第四个 for 循环的时间性能是 O(n),所以,算法 6.3 的时间复杂性为 O(n×C).

## **贪心法**求解**完全背包问题**

> 贪心法与其他算法求解背包问题区别如下:
>
> **1.在背包问题中可以将物品的一部分装入背包（物品可以拆分的装入背包）,但不能重复装入.**
>
> **2.在 01 背包中只用考虑每个物品放还是不放,完全背包中需要考虑放 0,1,2....[W/w[i]]件,所以叫完全背包.**
>
> 设 xi 表示物品 i 装入背包的情况,根据问题的要求,有如下约束条件和目标函数:
>
>$$
\begin{cases}\sum^n_{i=1} w_ix_i=C \\
0≤x_i≤1 \qquad (1≤i≤n)
\end{cases}
$$  (式7.1)
>
>
>
>$$
max \sum^n_{i=1} v_ix_i
$$  (式7.2)
>
> 于是,背包问题归结为寻找一个满足约束条件式 7.1,并使目标函数式 7.2 达到最大的解向量 X=(x1, x2, …, xn).
>
> 至少有三种看似合理的贪心策略:
>
> （1）选择**价值最大**的物品,因为这可以尽可能快地增加背包的总价值.但是,虽然每一步选择获得了背包价值的极大增长,但背包容量却可能消耗得太快,使得装入背包的物品个数减少,从而不能保证目标函数达到最大.
>
> （2）选择**重量最轻**的物品,因为这可以装入尽可能多的物品,从而增加背包的总价值.但是,虽然每一步选择使背包的容量消耗得慢了,但背包的价值却没能保证迅速增长,从而不能保证目标函数达到最大.
>
> （3）选择**单位重量价值最大**的物品,在背包价值增长和背包容量消耗两者之间寻找平衡.
>
> 应用第三种贪心策略,每次从物品集合中选择单位重量价值最大的物品,如果其重量小于背包容量,就可以把它装入,并将背包容量减去该物品的重量,然后我们就面临了一个最优子问题——它同样是背包问题,只不过背包容量减少了,物品集合减少了.因此背包问题具有最优子结构性质.
>
> 例如,有 3 个物品,其重量分别是{20, 30, 10},价值分别为{60, 120, 50},背包的容量为 50,应用三种贪心策略装入背包的物品和获得的价值如图所示.
>
> ![](https://img-blog.csdnimg.cn/20190715145406104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI2MDEwMg==,size_16,color_FFFFFF,t_70)
>
> 设背包容量为 C,共有 n 个物品,物品重量存放在数组 w[n]中,价值存放在数组 v[n]中,问题的解存放在数组 x[n]中.

```cpp
改变数组w和v的排列顺序,使其按单位重量价值v[i]/w[i]降序排列;
将数组x[n]初始化为0;  //初始化解向量
i=1;
循环直到(w[i]>C)
        x[i]=1;     //将第i个物品放入背包
        C=C-w[i];
        i++;
 x[i]=C/w[i];

```

> 算法 7.6 的时间主要消耗在将各种物品依其单位重量的价值从大到小排序.因此,其时间复杂性为 O(nlog2n).

## 附两道蓝桥杯的题目,考察的正是背包问题的知识点

### 第一道(完全背包问题)

[点击获取题目链接](http://oj.hzjingma.com/p/7157?view=classic)

> 题目说明了每笼包子的个数,但是每种蒸笼的笼子是无限的,既由此想到完全背包问题.如果要凑出包子数,则要满足 a1x1+a2x2+a3x3+…+anxn=c,这类不定方程.
>
> 背包的体积就是任意一个数,物品就是给定数字,物品的价值体积都是数字值,但是我们用不到价值
>
> 只有背包可以填满就好
>
> 每个 Ai 为物品的体积。观察数据发现 N 为 100,Ai 最多为 100,那么背包的容量设置为 10000 左右即可,如果不放心可以设置为 100000 左右.
>
> 那么我们看一定范围内的数字,有多少个不可以通过完全背包背出来,这些累加就是不可组合的数量.
>
> 首先考虑什么情况下是 INF,即当所有的包子 Ai,都不互质时那么就是 INF，否则一定会凑到一定程度时后面的包子全都能凑出。
>
> 即如果蒸笼$a_i$的最大公因数为 1,那么当包子数足够大时,总是能够表示的.
>
> 反之,如果蒸笼$a_i$的最大公因数不为 1,那么认为不能表示的数是无限的.

```cpp
#include<iostream>
using namespace std;
const int maxn=1e5;
int dp[maxn];               //dp[i]表示要i个包子是否可行
int a[105];             //a[i]表示第i笼包子的个数
int gcd(int a,int b)     //求最大公因数
{
    return b?gcd(b,a%b):a;
}
int main()
{
    int n,num=0;
    cin>>n;
    for (int  i = 0; i < n; i++)
    {
        cin>>a[i];
    }
    int g=gcd(a[0],a[1]);
    for (int  i = 2; i < n; i++)
    {
        g=gcd(g,a[i]);                     //最终g为所有a[i]的公共最大公因数
    }
    if(g!=1) {              //如果最大公因数不为1
        cout<<"INF"<<endl;
        return 0;
    }
    dp[0]=1;         //0个包子肯定可行
    for (int  i = 0; i < n; i++)
    {
        for (int  j = 0; j+a[i] < maxn; j++)
        {
            if(dp[j])
            {
                dp[j+a[i]]=1;
            }
        }

    }
    for (int i = 0; i < maxn; i++)
    {
        if(!dp[i])
        {
            num++;
        }
    }
    cout<<num<<endl;
    return 0;
}
```

### 第二道(01 背包问题)

[点击获取题目链接](http://oj.hzjingma.com/p/7108?view=classic)

> 首先给出暴力解法可以过掉一半用例的程序

```cpp
#include<stdio.h>
#include<algorithm>
int main()
{
    int K,n;
 //    int a[n];                  attention
    int res;
    scanf("%d %d",&n,&K);
       int a[n];         //n输入后才可定义a[n]数组
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
    }

    std::sort(a,a+n);

    for (int  i = n-1; i >1; i--)
    {
        for (int j = i-1 ; j >0; j--)
        {
            for (int k = j-1; k >=0; k--)
            {
                if((a[i]+a[j]+a[k])%K==0)
                {
                    res=a[i]+a[j]+a[k];
                    goto p;
                }
            }

        }

    }
    p:
    printf("%d",res);
    return 0;
}

```

## 下面给出 01 背包解法

> **背包的常见套路**
>
> **一般状态表示的时候,把限制放到维数里面,一般有几个限制,就用几维的状态表示.**
>
> 背包解法（一堆集合,从里面选出来一定量的东西,然后在满足一定的条件下,求一个最优解的问题）
>
> 可以把其中的一些数字给抹掉，比上面暴力解法更好一些
>
> 因为所有取模 k 得到的一样的数,可以当作一个集合来看,都是等价的;
>
> 所以说可以取最大的三个来代表这个集合里面的数;
>
> 至于

```cpp
f[j][k]=max(f[j][k],f[j-1][(k-x%m+m)%m]+x);
```

调试程序并手动草稿一个一个枚举即可得出此关系式.

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>  //attention
using namespace std;
const int N =1010;
vector<int> a[N];     //相当于二维数组，相同余数的数放到一行
int main()
{

    int n,m;
    scanf("%d%d",&n,&m);     //scanf和printf比cin、cout快
   // cin>>n>>m;
    int f[4][m];        //attention 最好用 N 代替  m
    //4代表当前选的数，N代表余数，即f[i][j]表示当前总共选i个数，i个数之和余数为j
    for (int  i = 0; i < n; i++)
    {
        int b;
        scanf("%d",&b);
        //cin>>b;
        a[b%m].push_back(b);       //将数按余数分组
    }
    memset(f,-0x3f3f3f,sizeof(f));    //将f数组中的每个元素初始化为-∞
    f[0][0]=0;
    for (int  i = 0; i < m; i++)       //枚举余数背包
    {
         // sort(a[i].rbegin(), a[i].rend());//rbegin() 返回一个逆序迭代器，它指向容器最后一个元素,rend() 返回一个逆序迭代器，它指向容器第一个元素前面的位置
        sort(a[i].begin(),a[i].end());   //attention  从大到小排序
        reverse(a[i].begin(),a[i].end());  //attention
        for (int  u = 0; u < 3&&u<a[i].size(); u++) //每个分组最多选三个最大的
        {
            int x=a[i][u];
            for (int  j = 3; j >= 1; j--)
            //for(int j=1;j<=3;j++)
            {
                for (int  k = 0; k < m; k++)   //枚举余数
                {
                    f[j][k]=max(f[j][k],f[j-1][(k-x%m+m)%m]+x);   //f[j - 1][(k - x%m + m) % m] + x保证相加后的余数为k
                }

            }

        }

    }
    printf("%d",f[3][0]);   //输出当选择三个数时余数为0三数的最大和(最优解)
    //cout<<f[3][0]<<endl;
    return 0;

}

```

> **特别要注意的是:**

```cpp
for (int  j = 3; j >= 1; j--)
```

> 当 j 倒序循环遍历时为 01 背包问题,即限定每种物品只能选择 0 个或 1 个

```cpp
for(int j=1;j<=3;j++)
```

> 当 j 正序循环遍历时为完全背包问题，即每种物品可以有无限多个.

<br>
参考文献: 
<br>
[1]王红梅.算法分析与设计[M].清华大学出版社:北京,2006.07:1.
<br>
<br>
参考链接:
<br>
1.https://zhuanlan.zhihu.com/p/93857890

2.https://www.cnblogs.com/rstz/p/12610987.html

3.https://www.codenong.com/cs105419494/

4.https://www.cnblogs.com/arsenalfaninecnu/p/8945548.html

5.https://blog.csdn.net/weixin_42260102/article/details/95967892
