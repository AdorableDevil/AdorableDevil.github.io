---
title: 背包问题
tags: 算法
layout: post
---

## What is 背包问题

> 
背包问题（Knapsack problem）是一种组合优化的 NP 完全问题.问题可以描述为:给定一组物品,每种物品都有自己的重量和价格,在限定的总重量内,我们如何选择,才能使得物品的总价格最高.问题的名称来源于如何选择最合适的物品放置于给定背包中.
>
相似问题经常出现在商业、组合数学,计算复杂性理论、密码学和应用数学等领域中.

> 
也可以将背包问题描述为决定性问题,即在总重量不超过 W 的前提下,总价值是否能达到 V.

## 背包问题的分类
>
1.01背包问题
>
2.完全背包问题
>
3.多重背包问题

> 我们有 n 种物品,物品 j 的重量为 wj,价格为 pj.
>
> 我们假定所有物品的重量和价格都是非负的.背包所能承受的最大重量为 W.
>
> 如果限定每种物品只能选择 0 个或 1 个,则问题称为**0-1 背包问题**.
>
> 可以用公式表示为:
>
> 最大化 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/5afdaef4d007e84cf2371df93cf7bdc891ddc1d4)
>
> 受限于 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/4302b7359d0374df8424621a29a8a4f41f8d017c)
>
> 如果限定物品 j 最多只能选择 bj 个,则问题称为**有界背包问题**.
>
> 可以用公式表示为:
>
> 最大化 ![](https://wikimedia.org/api/rest_v1/media/math/render/svg/5afdaef4d007e84cf2371df93cf7bdc891ddc1d4)
>
> 受限于![](https://wikimedia.org/api/rest_v1/media/math/render/svg/dcc77ece1703114b78feaf35faa0e99de9b4b34a)
>
> 如果不限定每种物品的数量,则问题称为**无界背包问题** .
>
各类复杂的背包问题总可以变换为简单的 0-1 背包问题进行求解.
>
**完全背包（unbounded knapsack problem）**与01背包不同就是每种物品可以有无限多个:一共有N种物品,每种物品有无限多个,第i（i从1开始）种物品的重量为w[i],价值为v[i].在总重量不超过背包承载上限W的情况下,能够装入背包的最大价值是多少？
>
**多重背包（bounded knapsack problem）**与前面不同就是每种物品是有限个:一共有N种物品,第i（i从1开始）种物品的数量为n[i],重量为w[i],价值为v[i].在总重量不超过背包承载上限W的情况下,能够装入背包的最大价值是多少？

## **动态规划法**求解**0-1 背包问题**

> 在 0/1 背包问题中,物品 i 或者被装入背包,或者不被装入背包,设 xi 表示物品 i 装入背包的情况,则当 xi=0 时,表示物品 i 没有被装入背包,xi=1 时,表示物品 i 被装入背包.根据问题的要求,有如下约束条件和目标函数:
>
$$
\begin{cases}\sum^n_{i=1} w_ix_i≤C \\
x_i\in\{0,1\} \qquad (1≤i≤n)
\end{cases}
$$      (式6.9)
> 
于是,问题归结为寻找一个满足约束条件式 6.9,并使目标函数式 6.10 达到最大的解向量 X=(x1, x2, …, xn).
>
> 0/1 背包问题可以看作是决策一个序列(x1, x2, …, xn),对任一变量 xi 的决策是决定 xi=1 还是 xi=0.在对 xi-1 决策后,已确定了(x1, …, xi-1),在决策 xi 时,问题处于下列两种状态之一:
>
> （1）背包容量不足以装入物品 i,则 xi=0,背包不增加价值；
>
> （2）背包容量可以装入物品 i,则 xi=1,背包的价值增加了 vi.
>
> 这两种情况下背包价值的最大者应该是对 xi 决策后的背包价值.令 V(i, j)表示在前 i(1≤i≤n)个物品中能够装入容量为 j（1≤j≤C）的背包中的物品的最大值,则可以得到如下动态规划函数:
>
> V(i, 0)= V(0, j)=0 （式 6.11）
>
> V(i,j)=$$  \begin{cases}
V(i-1,j)    \qquad j＜w_i      \\      
max \{V(i-1,j),V(i-1,j-w_i)+v_i\} \qquad  j>w_i
\end{cases}$$ （式 6.12）

> 式 6.11 表明:把前面 i 个物品装入容量为 0 的背包和把 0 个物品装入容量为 j 的背包,得到的价值均为 0.式 6.12 的第一个式子表明:如果第 i 个物品的重量大于背包的容量,则装入前 i 个物品得到的最大价值和装入前 i-1 个物品得到的最大价值是相同的,即物品 i 不能装入背包；第二个式子表明:如果第 i 个物品的重量小于背包的容量,则会有以下两种情况:（1）如果把第 i 个物品装入背包,则背包中物品的价值等于把前 i-1 个物品装入容量为 j-wi 的背包中的价值加上第 i 个物品的价值 vi；（2）如果第 i 个物品没有装入背包,则背包中物品的价值就等于把前 i-1 个物品装入容量为 j 的背包中所取得的价值.显然,取二者中价值较大者作为把前 i 个物品装入容量为 j 的背包中的最优解.
>
> 按下述方法来划分阶段:第一阶段,只装入前 1 个物品,确定在各种情况下的背包能够得到的最大价值；第二阶段,只装入前 2 个物品,确定在各种情况下的背包能够得到的最大价值；依此类推,直到第 n 个阶段.最后,V(n,C)便是在容量为 C 的背包中装入 n 个物品时取得的最大价值.为了确定装入背包的具体物品,从 V(n,C)的值向前推,如果 V(n,C)>V(n-1,C),表明第 n 个物品被装入背包,前 n-1 个物品被装入容量为 C-wn 的背包中；否则,第 n 个物品没有被装入背包,前 n-1 个物品被装入容量为 C 的背包中.依此类推,直到确定第 1 个物品是否被装入背包中为止.由此,得到如下函数:
>
> $ x_i $=$$  \begin{cases}
0     \qquad  V(i,j)=V(i-1,j)  \\      
1,j=j-w_i \qquad  V(i,j)>V(i-1,j)
\end{cases}$$ （式 6.13）
>
> 例如,有 5 个物品,其重量分别是{2, 2, 6, 5, 4},价值分别为{6, 3, 5, 4, 6},背包的容量为 10.
>
> 根据动态规划函数,用一个(n+1)×(C+1)的二维表 V,V[i][j]表示把前 i 个物品装入容量为 j 的背包中获得的最大价值.
>
> 例如,有 5 个物品,其重量分别是{2, 2, 6, 5, 4},价值分别为{6, 3, 5, 4, 6},背包的容量为 10.
>
> 根据动态规划函数,用一个(n+1)×(C+1)的二维表 V,V[i][j]表示把前 i 个物品装入容量为 j 的背包中获得的最大价值.
>
> ![](https://img2018.cnblogs.com/blog/798398/201909/798398-20190901170651326-2046946349.png)
>
> 设 n 个物品的重量存储在数组 w[n]中,价值存储在数组 v[n]中,背包容量为 C,数组 V[n+1][c+1]存放迭代结果,其中 V[i][j]表示前 i 个物品装入容量为 j 的背包中获得的最大价值,数组 x[n]存储装入背包的物品,动态规划法求解 0/1 背包问题的算法如下:

```cpp
int KnapSack(int n, int w[ ], int v[ ])
   {
     for (i=0; i<=n; i++)   //初始化第0列
       V[i][0]=0;
     for (j=0; j<=C; j++)   //初始化第0行
       V[0][j]=0;
     for (i=1; i<=n; i++)   //计算第i行,进行第i次迭代
       for (j=1; j<=C; j++)
          if (j<w[i])
			V[i][j]=V[i-1][j];
         else
			V[i][j]=max(V[i-1][j], V[i-1][j-w[i]]+v[i]);
     j=C;    //求装入背包的物品
     for (i=n; i>0; i--)
     {
       if (V[i][j]>V[i-1][j]) {
         x[i]=1;
         j=j-w[i];
       }
       else x[i]=0;
     }
  return V[n][C];    //返回背包取得的最大价值


```
>
在算法6.3中,第一个for循环的时间性能是O(n),第二个for循环的时间性能是O(C),第三个循环是两层嵌套的for循环,其时间性能是O(n×C),第四个for循环的时间性能是O(n),所以,算法6.3的时间复杂性为O(n×C). 


## **贪心法**求解**完全背包问题**
>
贪心法与其他算法求解背包问题区别如下:
>
**1.在背包问题中可以将物品的一部分装入背包（物品可以拆分的装入背包）,但不能重复装入.**
>
**2.在01背包中只用考虑每个物品放还是不放,完全背包中需要考虑放0,1,2....[W/w[i]]件,所以叫完全背包.**
>
设xi表示物品i装入背包的情况,根据问题的要求,有如下约束条件和目标函数:
> 
$$
\begin{cases}\sum^n_{i=1} w_ix_i=C \\
0≤x_i≤1 \qquad (1≤i≤n)
\end{cases}
$$      (式7.1)
>
$$
max \sum^n_{i=1} v_ix_i
$$  (式7.2)
>
于是,背包问题归结为寻找一个满足约束条件式7.1,并使目标函数式7.2达到最大的解向量X=(x1, x2, …, xn).
>
至少有三种看似合理的贪心策略: 
>
（1）选择**价值最大**的物品,因为这可以尽可能快地增加背包的总价值.但是,虽然每一步选择获得了背包价值的极大增长,但背包容量却可能消耗得太快,使得装入背包的物品个数减少,从而不能保证目标函数达到最大.
>
（2）选择**重量最轻**的物品,因为这可以装入尽可能多的物品,从而增加背包的总价值.但是,虽然每一步选择使背包的容量消耗得慢了,但背包的价值却没能保证迅速增长,从而不能保证目标函数达到最大.
>
（3）选择**单位重量价值最大**的物品,在背包价值增长和背包容量消耗两者之间寻找平衡.
>
应用第三种贪心策略,每次从物品集合中选择单位重量价值最大的物品,如果其重量小于背包容量,就可以把它装入,并将背包容量减去该物品的重量,然后我们就面临了一个最优子问题——它同样是背包问题,只不过背包容量减少了,物品集合减少了.因此背包问题具有最优子结构性质.
>
例如,有3个物品,其重量分别是{20, 30, 10},价值分别为{60, 120, 50},背包的容量为50,应用三种贪心策略装入背包的物品和获得的价值如图所示.
>
![](https://img-blog.csdnimg.cn/20190715145406104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjI2MDEwMg==,size_16,color_FFFFFF,t_70)
>
设背包容量为C,共有n个物品,物品重量存放在数组w[n]中,价值存放在数组v[n]中,问题的解存放在数组x[n]中. 

```cpp
改变数组w和v的排列顺序,使其按单位重量价值v[i]/w[i]降序排列；
将数组x[n]初始化为0；  //初始化解向量
i=1;      
循环直到(w[i]>C)
        x[i]=1;     //将第i个物品放入背包
        C=C-w[i];
        i++;
 x[i]=C/w[i];

```
>
算法7.6的时间主要消耗在将各种物品依其单位重量的价值从大到小排序.因此,其时间复杂性为O(nlog2n).

## 附两道蓝桥杯的题目,考察的正是背包问题的知识点 ##

### 第一道 ###

[点击获取题目链接](http://oj.hzjingma.com/p/7157?view=classic)
>
题目说明了每笼包子的个数,但是每种蒸笼的笼子是无限的,既由此想到完全背包问题.如果要凑出包子数,则要满足a1x1+a2x2+a3x3+…+anxn=c,这类不定方程.
>
背包的体积就是任意一个数,物品就是给定数字,物品的价值体积都是数字值,但是我们用不到价值
>
只有背包可以填满就好
>
那么我们看一定范围内的数字,有多少个不可以通过完全背包背出来,这些累加就是不可组合的数量.
>
如果蒸笼$a_i$的最大公因数为1,那么当包子数足够大时,总是能够表示的.
>
反之,如果蒸笼$a_i$的最大公因数不为1,那么认为不能表示的数是无限的

```cpp
#include<iostream>
using namespace std;
const int maxn=1e5;
int dp[maxn];               //dp[i]表示要i个包子是否可行
int a[105];             //a[i]表示第i笼包子的个数
int gcd(int a,int b)     //求最大公因数
{
    return b?gcd(b,a%b):a;
}
int main()
{
    int n,num=0;
    cin>>n;
    for (int  i = 0; i < n; i++)
    {
        cin>>a[i];
    }
    int g=gcd(a[0],a[1]);
    for (int  i = 2; i < n; i++)
    {
        g=gcd(g,a[i]);                     //最终g为所有a[i]的公共最大公因数
    }
    if(g!=1) {              //如果最大公因数不为1
        cout<<"INF"<<endl;
        return 0;
    }
    dp[0]=1;         //0个包子肯定可行
    for (int  i = 0; i < n; i++)
    {
        for (int  j = 0; j+a[i] < maxn; j++)
        {
            if(dp[j])
            {
                dp[j+a[i]]=1;
            }
        }
        
    }
    for (int i = 0; i < maxn; i++)
    {
        if(!dp[i])
        {
            num++;
        }
    }
    cout<<num<<endl;
    return 0;
}
```

### 第二道 ###

[点击获取题目链接](http://oj.hzjingma.com/p/7108?view=classic)

>
**背包的常见套路**
>
**一般状态表示的时候,把限制放到维数里面,一般有几个限制,就用几维的状态表示.**
>
背包解法（一堆集合,从里面选出来一定量的东西,然后在满足一定的条件下,求一个最优解的问题）
>
可以把其中的一些数字给抹掉
>
因为所有取模k 得到的一样的数,可以当作一个集合来看,都是等价的；
>
所以说可以取最大的三个来代表 这个集合里面的数；

```cpp
include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

const int N = 1010;
vector<int> a[N];  //用来存放余数一样的数字的集合
int n,m;
int f[4][N]; //从后往前遍历,可以省略中间那一维的遍历

int main()
{
    scanf("%d%d",&n,&m);
   
    for(int i = 0; i < n;i++)
    {
        int x;
        scanf("%d",&x);
        a[x % m].push_back(x);
    }
   
    memset(f,-0x3f,sizeof f);  //状态函数全部置为负无穷
    f[0][0] = 0;
   
    for(int i = 0;i < m;i++)
    {
        sort(a[i].begin(),a[i].end());
        reverse(a[i].begin(),a[i].end());  //转化为从大到小的
       
        for(int u = 0;u < 3 && u < a[i].size();u++)  //遍历灭一个集合的最大值
        {
            int x = a[i][u];
            for(int j = 3;j > 0;j--)  //遍历第一维:从几个数字中选择
                for(int k = 0;k < m;k++)  //遍历第三维
                    f[j][k] = max(f[j][k],f[j  - 1][(k - x % m + m) % m] + x);
                   
        }
    }
   
    printf("%d\n",f[3][0]);
    return 0;
 
}
```

参考文献: 
<br>
[1]王红梅.算法分析与设计[M].清华大学出版社:北京,2006.07:1.
<br>
参考链接:
<br>
1.https://zhuanlan.zhihu.com/p/93857890

2.https://www.codenong.com/cs105419494/

3.https://www.cnblogs.com/arsenalfaninecnu/p/8945548.html  

4.https://blog.csdn.net/weixin_42260102/article/details/95967892


