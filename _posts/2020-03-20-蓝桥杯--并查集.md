---
title: 蓝桥杯--并查集
tags: 算法
layout: post
---
## What is 并查集
> 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。

## 并查集的操作有三步
##### 第一步,点的初始化:

既然并查集是来查找祖先的，那么初始化就必然是让每个点的祖先指向自己.

```cpp
for(int i=1;i<=n;++i) fa[i]=i;
```
##### 第二步,查找祖先:

查找操作就是不断地向上走，直到找到祖先为止.

```cpp
while(x!=fa[x]) x=fa[x];
```
##### 第三步。合并：

合并操作就是把一个节点的祖先变为另一个节点的祖先。

```cpp
fa[find(a)]=find(b);//其中find(x)为x的祖先
```

并查集的单次查询理想复杂度应该是O(logn)的，但是如果有一个这样的数据，并查集的复杂度就是O(n)了

![查找结果](https://gitee.com/adorabledevil/picture-storage/raw/master/3812b31bb051f819c8c68198dcb44aed2f73e705.png)

为了避免这种情况，我们需对路径进行压缩。

即当我们经过找到祖先节点后，回溯的时候顺便将它的子孙节点都直接指向祖先，使以后的查找复杂度变回O(logn)甚至更低，让图变成这样： 

![查找结果](https://gitee.com/adorabledevil/picture-storage/raw/master/u=1884200678,1820405564&fm=11&gp=0_%E5%89%AF%E6%9C%AC.jpg)

听上去十分高端，实际上只要把刚刚的查询操作变成如下就可以了
```cpp
while(x!=fa[x]) x=fa[x]=fa[fa[x]];
```

#### 下面对应题目：

[【模板】并查集的题目](https://www.luogu.com.cn/problem/P3367)

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,z,x,y,fa[10005];//fa[i]是第i号节点的祖先
inline int find(int x)
{
    while(x!=fa[x]) x=fa[x]=fa[fa[x]];
    //让x和x的父亲变成他的父亲的父亲
    //直到找到祖先才结束循环(x==fa[x])就意味着找到爹了
    return x;
}
//循环版找爹函数
/*
//再附上递归版本的找爹函数
inline int find(int x) 
{
    if (x==fa[x]) return x;
    //不停的递归查找
    return fa[x]=find(fa[x]);
    //路径压缩，可以缩短时间
}
*/
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;++i) 
    {
        fa[i]=i;
        //并查集的初始化
    }
    while(m--)
    {
        cin>>z>>x>>y;
        int a=find(x),b=find(y);
        //ab分别去找自己的爹
        if(z==1)
        {
            fa[a]=b;
            //并查集的合并操作，及将x点祖先的爹记为y点的祖先
        }
        if(z==2)
        {
            if(a==b) 
            {
                puts("Y");
                //爹一样就说明X与Y是在同一集合内，输出Y
            }
            else 
            {
                puts("N");
                //否则就说明X与Y是在同一集合内，输出N
            }
        } 
    }
    return 0;
}
```

#### 对应于第十届蓝桥杯省赛 A 组，试题 H: 修改数组
![查找结果](http://oj.hzjingma.com/uploads/20200127/15801054255822.png)

输入：

![查找结果](http://oj.hzjingma.com/uploads/20200127/15801054456660.png)

输出：

![查找结果](http://oj.hzjingma.com/uploads/20200127/15801054544334.png)

样例：

![查找结果](https://img-blog.csdnimg.cn/20200320235529948.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fkb3JhYmxlRGV2aWw=,size_16,color_FFFFFF,t_70)

提示：

![查找结果](https://img-blog.csdnimg.cn/2020032023564269.PNG)

#### 第一次代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int N;
	cin>>N;
	int  a[N]={0};
	for(int i=0;i<N;i++)
	{
		
		cin>>a[i];
			for(int j=0;j<i;j++)
	{
		if(a[i]==a[j])
		{
			a[i]++;
			j=-1;
		}
	}
	}
	
	for(int i=0;i<N;i++)
	{
		cout<<a[i]<<" ";
	}
	
} 
```

####  结果：
![](https://img-blog.csdnimg.cn/20200321000431358.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Fkb3JhYmxlRGV2aWw=,size_16,color_FFFFFF,t_70)

#### 显然得用并查集解决问题，修改后代码如下：
```cpp
#include<bits/stdc++.h> 
using namespace std;
#define max 1100000
int  f[max+1],a[100001];
int find(int x)
{
	if(f[x]==x)
	{
		return x;
	 } 
	 else {
	 	f[x]=find(f[x]);
	 	return f[x]; 
	 }
} 
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=max;i++)
	{
		f[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]=find(a[i]);
		f[a[i]]=a[i]+1;
	}
	for(int i=1;i<=n;i++)
	{
		cout<<a[i]<<" ";
		
	}
}

```
#### 有一个问题需要明确，如果一直插入 1000000，那么到最后的数字会超出 1000000，所以最小max设置为 1100000即可。




参考链接：


https://www.luogu.com.cn/problemnew/solution/P3367